/*
================================================================================
=      Modelo Estratégico e Tático para o Domínio Ludum                       =
================================================================================
*/

// Definição do Domínio e seus Subdomínios
Domain Ludum {
  Subdomain Identidade {
    type = SUPPORTING_DOMAIN
  }

  Subdomain Catalogo {
    type = CORE_DOMAIN
  }

  Subdomain Financeiro {
    type = SUPPORTING_DOMAIN
  }

  Subdomain Comunidade {
    type = SUPPORTING_DOMAIN
  }

  Subdomain Crowdfunding {
    type = SUPPORTING_DOMAIN
  }

  Subdomain OficinaDeMods {
    type = SUPPORTING_DOMAIN
  }

}

// ================================================================================
// CONTEXTO: Identidade
// Gerencia contas, perfis e as relações sociais (seguir, bloquear).
// ================================================================================
BoundedContext Identidade implements Identidade {
Aggregate Conta {
  Entity Conta {
  aggregateRoot
  -ContaId id
  String nome
  String senha_hash // Armazenar hash, não a senha
  -TipoConta tipo
  -StatusConta status
  void publicarJogo(JogoId jogoId);
}
Repository ContaRepository {
      void salvar(Conta conta);
      Conta obterPorId(ContaId id);
    }
    ValueObject ContaId { String id }
    enum TipoConta { JOGADOR, DESENVOLVEDORA }
    enum StatusConta { ATIVA, INATIVA }
  }

  // AGGREGATE SEPARADO PARA RELACIONAMENTOS (MELHOR PRÁTICA)
  // Evita carregar listas gigantes no agregado Conta.
  Aggregate Seguimento {
    Entity Seguimento {
		aggregateRoot
		-SeguimentoId id
		-ContaId seguidorId
		-AlvoId seguidoId
		-TipoAlvo tipoAlvo
    }

    Repository SeguimentoRepository {
		void salvar(Seguimento seguimento);
		void remover(Seguimento seguimento);
		Seguimento obter(ContaId seguidorId, AlvoId seguidoId);
		List<Seguimento> obterSeguidoresDe(AlvoId seguidoId);
		List<Seguimento> obterSeguidosPor(ContaId seguidorId);
    }
    ValueObject SeguimentoId { String id }
    ValueObject AlvoId { String id }

    enum TipoAlvo { CONTA, JOGO, TAG, DESENVOLVEDORA }

  }

  // Bloqueio também é um agregado próprio para gerenciar o relacionamento.
  Aggregate Bloqueio {
    Entity Bloqueio {
      -ContaId bloqueadorId
      -ContaId bloqueadoId
    }
    Repository BloqueioRepository {
      void salvar(Bloqueio bloqueio);
      void remover(Bloqueio bloqueio);
      Bloqueio buscar(ContaId bloqueadorId, ContaId alvoId);
    }
    BloqueioId { String id }
  }

  Service RelacionamentoService {
    // Note que agora os serviços interagem com os repositórios corretos.
    void seguirAlvo(ContaId seguidorId, AlvoId alvoId, TipoAlvo tipoAlvo);
    void deixarDeSeguirAlvo(ContaId seguidorId, AlvoId alvoId);
    void bloquearConta(ContaId bloqueadorId, ContaId alvoId);
    void desbloquearConta(ContaId bloqueadorId, ContaId alvoId);
  }
}

// ================================================================================
// CONTEXTO: Catalogo
// Gerencia o ciclo de vida dos jogos: upload, validação e publicação.
// ================================================================================
BoundedContext Catalogo implements Catalogo {
Aggregate Jogo {
  Entity Jogo {
  aggregateRoot
  -JogoId id
  -ContaId desenvolvedoraId
  -Slug slug
  URL capaOficial
  -StatusPublicacao status
  String titulo
  String descricao
  List<URL> screenshots
  List<URL> videos
  List<Tag> tags
  boolean isNSFW
  Date dataDeLancamento
  List<Versao> versaoHistory
  Slug montarSlug(
  String titulo);
  void publicar();
      void rejeitar();
      void arquivar();
      void validarParaPublicacao();
      void adicionarVersao(Versao versao)
}
ValueObject JogoId { String id }
    ValueObject Slug { String valor }
    ValueObject PacoteZip { byte[] conteudo }

    Repository JogoRepository {
      void salvar(@Jogo jogo);
      Jogo obterPorId(@JogoId id);
      Jogo obterPorSlug(@Slug slug);
      boolean existeSlugParaDesenvolvedora(@ContaId devId, @JogoId jogo); 
      List<Jogo> obterJogosPorTag(@Tag tag);
    }
    
    Entity Versao{
      -VersaoId id
      -JogoId jogoId
      -PacoteZip
      String nomeVersao
      String descricaoVersao
      void validarPacoteZip(@PacoteZip pacoteZip)
      void validarNomeVersao(String nomeVersao)
    }

    ValueObject VersaoId { String id }

    Service GestaoDeJogosService {
      void processarUpload(@ContaId devId, Versao versao)
      boolean verificarMalware(PacoteZip pacote)
    }

    Service PublicacaoService {
      void publicarJogo(@ContaId devId, @JogoId jogoId)
      void rejeitarJogo(@JogoId jogoId, String motivo)
      void arquivarJogo(@ContaId devId, @JogoId jogoId)
    }

    enum StatusPublicacao { EM_UPLOAD, AGUARDANDO_VALIDACAO, PUBLICADO, REJEITADO, ARQUIVADO }

  }

  Aggregate Tag {
    Entity Tag {
      aggregateRoot
      -TagId id
      String nome
    }

    ValueObject TagId { String id }

    Repository TagRepository {
      Tag obterPorNome(String nome)
      void salvar(Tag tag)
      Tag obterPorId(TagId id)
      List<Tag> obterTodas()
      void remover(Tag tag)
    }
  }
}

// ================================================================================
// CONTEXTO: Catalogo
// Gerencia a aquisição, a biblioteca do usuário e o acesso (download).
// ================================================================================
BoundedContext CatalogoBiblioteca implements CatalogoBiblioteca {
Aggregate Biblioteca {
  Entity Biblioteca {
  aggregateRoot
  -@ContaId jogadorId
  List<ItemBiblioteca> itens // Essencial para o agregado, OK.
  ItemBiblioteca checaPresencaDeJogo(
  @JogoId jogoId)
    void adicionarJogo(@ModeloDeAcesso modeloDeAcesso, @JogoId jogoId)
	  void removerJogo(@JogoId jogoId)
}
Repository BibliotecaRepository {
      Biblioteca obterPorJogador(ContaId jogadorId);
      void salvar(Biblioteca biblioteca);
    }

    Service BibliotecaService {
	  void adiconarJogo(@JogoId jogoId, @ContaId jogadorId, @TransacaoId Transacaoid, @ModeloDeAcesso modelo)
      PacoteZip ProcessarDownload(@ContaId jogadorId, JogoId jogoId);
    }
 
    ValueObject ItemBiblioteca { 
		-JogoId jogoId;
		Date dataAquisicao;
		-ModeloDeAcesso modelo 
		}
    enum ModeloDeAcesso { GRATUITO, PAGO }
  }
}

// ================================================================================
// CONTEXTO: Financeiro
// Gestão da carteira, saldos, transações e saques.
// ================================================================================
BoundedContext Financeiro implements Financeiro {
Aggregate Carteira {
  Entity Carteira {
  aggregateRoot
  -ContaId contaId
  Saldo saldo
  boolean contaExternaValida
  void liberarSaldoBloqueado();
}
Repository CarteiraRepository {
      Carteira obterPorContaId(ContaId contaId);
      void salvar(@Carteira carteira);
    }


    Service OperacoesFinanceirasService { 
      boolean comprarJogo(Conta jogadorId, JogoId jogoId, Valor valorOfertado);
      boolean solicitarReembolso(Conta jogadorId, ReciboId reciboId);
      boolean adicionarSaldo(Carteira carteira, BigDecimal valor, boolean pagamentoConfirmado);
      boolean solicitarSaque(Carteira carteira, BigDecimal valor, boolean contaValidada, Date dataVenda, boolean isCrowdfunding, boolean metaAtingida);
	 }

    ValueObject ContaId { String id }
    ValueObject Saldo { BigDecimal disponivel; BigDecimal bloqueado }

   
  }

	Aggregate Transacao {
      Entity Transacao {
		aggregateRoot
        -TransacaoId id
        -ContaId contaOrigem
        -ContaId contaDestino
        TipoTransacao tipo
        StatusTransacao status
        Date data
        BigDecimal valor


      }

    Repository TransacaoRepository {
        void salvar(Transacao transacao);
        Transacao obterPorId(TransacaoId id);
        List<Transacao> obterHistoricoPorConta(ContaId contaId, DatePeriodo periodo);
        void salvarRecibo(Recibo recibo);
    }



	Entity Recibo { 
		-ReciboId id;
		Date data;
		BigDecimal valorPago;
	}

	ValueObject ReciboId { String id }
  ValueObject TransacaoId { String id }

	 enum TipoTransacao { CREDITO, DEBITO, SAQUE, PIX }
   enum StatusTransacao { PENDENTE, CONFIRMADA, CANCELADA }

    }
}

// ================================================================================
// CONTEXTO: Crowdfunding
// Gerencia o financiamento coletivo (Crowdfunding).
// ================================================================================
BoundedContext Crowdfunding implements Crowdfunding {
Aggregate Campanha {
  Entity Campanha {
  -CampanhaId id
  -JogoId jogoId
  -DesenvolvedoraId desenvolvedoraId
  MetaFinanceira meta
  double valorArrecadado
  -Periodo periodo
  -StatusCampanha status
  void AlterarStatusDaCampanha();
	  BigDecimal ValorFaltante();
}
Repository CampanhaRepository {
			
			void salvarCampanha(@CampanhaId id)
			void fecharCampanha(@CampanhaId id)
		}

    Service GestaoDeCampanhasService { 
		
	 }

	ValueObject Periodo{
		Date dataInicio
      	Date dataFim

		void CalcularTempoRestante();
	}
	
  }

	 Aggregate Apoio {
      Entity Apoio {
        -ApoioId id
        -CampanhaId campanhaId
        -JogadorId apoiadorId
        -TransacaoId transacaoId 
        Date data
        boolean isCancelado
      }
    }
    Repository ApoioRepository {
        List<Apoio> obterApoiosDaCampanha(CampanhaId id);
        void salvarApoio(CampanhaId campanhaId, JogadorId jogadorId);
    }

	Service ApoioServico{
		void apoiarCampanha(@ContaId jogadorId, @CampanhaId campanhaId);
		void aumentarApoio(@ContaId jogadorId, @CampanhaId campanhaId)
	}

}

// ================================================================================
// CONTEXTO: Comunidade
// Interações da comunidade: posts e reviews.
// ================================================================================
BoundedContext Comunidade implements Comunidade {
Aggregate Post {
  Entity Post {
  aggregateRoot
  -PostId postId
  -JogoId jogoId
  -ContaId autorId
  String titulo
  String conteudo
  Date dataPublicacao
  URL Imagem
  -PostStatus status
  List<Tag> tags
  List<Comentario> comentarios;
  List<Curtida> curtidas;
  void editarConteudo(String novoTitulo, String novoConteudo);
      void adicionarCurtida(ContaId contaId);
      void removerCurtida(ContaId contaId);
      void adicionarComentario(Comentario comentario);
      void removerComentario(ComentarioId comentarioId, ContaId solicitanteId);
}
enum PostStatus{ PUBLICADO, EM_RASCUNHO, AGENDADO }

  ValueObject Curtida{
		-Post PostId
		-Conta contaId
	}

  ValueObject PostId { String id }
  ValueObject ComentarioId { String id }

  Entity Comentario {
    -ComentarioId id
    -PostId postId
    -ContaId autorId
    String texto
    Date data

    void editarTexto(String novoTexto);
  }


    Repository PostRepository {
      void salvar(Post post);
      Post obterPorId(PostId id);
      void remover(Post post);
      List<Post> obterTodosPosts();
      List<Post> obterPorAutor(ContaId autorId);
      List<Post> buscarPorTag(String tag);
	    List<Post> obterPorStatus(PostStatus);
    }

    Service PostService {
      void publicarPost(@ContaId autorId, String titulo, String conteudo);
      void editarPost(@PostId postId, @ContaId autorId, String novoTitulo, String novoConteudo);
      void curtirPost(@PostId postId, @ContaId contaId);
      void comentarPost(@PostId postId, @ContaId autorId, String texto);
      void removerPost(@PostId postId, @ContaId solicitanteId);
	    void agendarPost(@PostId, Date dataDeAgendamento)
	    void criarRascunho(@Post post, @ContaId contaId)
    }

  }

  Aggregate Review {
    Entity Review {
      aggregateRoot
      -ReviewId id
      -JogoId jogoId
      -ContaId autorId
      int nota        
      String titulo    
      String texto     
      Date data        
      boolean isRecomendado
      StatusReview status

      void editarConteudo(String novoTitulo, String novoTexto);
      void ajustarNota(int novaNota);
    }

    Repository ReviewRepository {
      void salvar(Review review);
      Review obterPorId(ReviewId id);
      List<Review> obterPorJogo(JogoId jogoId, int pagina, int tamanhoPagina);
      List<Review> obterPorAutor(ContaId autorId, int pagina, int tamanhoPagina);
      void remover(Review review);
    }

    Service ReviewService {
		
      void avaliarJogo(@JogoId jogoId, @ContaId autorId, int nota, String titulo, String texto, boolean recomenda);
      void editarAvaliacao(@ReviewId reviewId, @ContaId autorId, String novoTitulo, String novoTexto, int novaNota);
      void apagarAvaliacao(@ReviewId reviewId, @ContaId solicitanteId);
    }

    ValueObject ReviewId { String id }


    enum StatusReview { PUBLICADO, EDITADO }
  }
}

// ================================================================================
// CONTEXTO: OficinaDeMods
// Gerencia a criação e o uso de Mods.
// ================================================================================
BoundedContext OficinaDeMods implements OficinaDeMods {
  Aggregate Mod {
  Entity Mod {
    aggregateRoot
    -ModId id
    -JogoId jogoAssociado
    -Conta autorId
    String nome
    String descricao
    List<VersaoMod> versoes
  }
  Repository ModRepository {
		void salvar(InscricaoMod inscricao);
        void remover(InscricaoMod inscricao);
		List<Mod> getTodosModsPorJogo(@JogoId jogoId)
}

Service ModsService {
		void PublicarMod(@ContaId contaId, @JogoId jogoId, @ModId modId)
		void RemoverMod(@ModId modId)
	 }
    Entity VersaoMod { 
		String descricao
		PacoteZip mod
	}

	ValueObject PacoteZip{
		byte[] bytes;
	}

  }
}
